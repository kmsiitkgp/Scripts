# NOTE: CellChat output is purely statistical. It may predict some interactions
# to be more liekly in one dataset compared to another when in reality the 
# expression of ligands, receptors etc may not be very different between the
# datasets. To overcome this, rather than ENTIRELY relying on communication
# probabilties estimated by CellChat for each LR pair, ALWAYS IDENTIFY 
# DIFFERENTIAL EXPRESSION OF LR pairs. The following threads clearly show 
# predicted communication probabilities are not accurate.

# https://github.com/sqjin/CellChat/issues/329
# https://github.com/sqjin/CellChat/issues/384
# https://github.com/sqjin/CellChat/issues/291
# https://github.com/sqjin/CellChat/issues/342


# https://rdrr.io/github/sqjin/CellChat/f/     (Ctrl+F"tutorial" in this link)
# https://htmlpreview.github.io/?https://github.com/sqjin/CellChat/blob/master/tutorial/CellChat-vignette.html
# https://rdrr.io/github/sqjin/CellChat/f/tutorial/Comparison_analysis_of_multiple_datasets.Rmd
# Read https://www.nature.com/articles/s41467-021-21246-9   this paper to 
# understand how to use/interpret each of the plots generated by cellchat
# https://github.com/sqjin/CellChat/issues/400
# https://github.com/sqjin/CellChat/issues/7

# In a weighted-directed network with the weights as the computed communication
# probabilities, the out-degree, computed as the sum of communication 
# probabilities of the outgoing signaling from a cell group, and the in-degree, 
# computed as the sum of the communication probabilities of the incoming 
# signaling to a cell group, can be used to identify the dominant cell senders 
# and receivers of signaling networks, respectively. Flow betweenness score
# measures a group of cells’ capability as gatekeeper to control communication 
# flow between any two cell groups. The mediator score is quantified by flow
# betweenness metric from graph theory. Intuitively, it measures a group of 
# cells’ capability as gatekeeper to control communication flow between any two
# cell groups. The influencer is quantified by a hybrid measure called 
# information centrality. Basically, for information flow within a signaling 
# network, a higher value indicates greater influence on the information flow.

#******************************************************************************#
# NOTE: TO understand structure of CellChatDB or cellchat obejcts, refer below
# Use dplyr::glimpse(cellchat) or dplyr::glimpse(CellChatDB) to understand 
# structure of cellchat at each step of analysis. There are 15 slots in cellchat.
dplyr::glimpse(cellchat)

# Show the description of CellChatDB databse
showDatabaseCategory(CellChatDB)

# Show the structure of the database
dplyr::glimpse(CellChatDB$interaction)

names(CellChatDB)
# [1] "interaction" "complex"     "cofactor"    "geneInfo"

names(CellChatDB$interaction)
# [1] "interaction_name"   "pathway_name"       "ligand"
# [4] "receptor"           "agonist"            "antagonist"
# [7] "co_A_receptor"      "co_I_receptor"      "evidence"
# [10] "annotation"         "interaction_name_2"

unique(CellChatDB$interaction$annotation)
# [1] "Secreted Signaling" "ECM-Receptor"       "Cell-Cell Contact"
#******************************************************************************#

#******************************************************************************#
#             STEP 1: GENERATE CELL CHAT OBJECTS FOR EACH DATASET              #
#******************************************************************************#

# NOTE: I think we MUST run cell chat on each sample separately??

# Whether to project data to PPI
# NOTE: I HAVE NOTICED PROJECTING DATA TO PPI INTRODUCES interactions like 
# H2-K1:Cd8a in Epitheilal-Epithelial interactions
project_data <- FALSE

# Whether data is unsorted single cell data
unsorted_data <- TRUE

# define a positive dataset, i.e., the dataset with positive fold change against the other dataset
pos.dataset = "Male"

# define a char name used for storing the results of differential expression analysis
features.name = pos.dataset

# Save as excel
wb <- openxlsx::createWorkbook()

# Load seurat object
celltype <- NULL
integrated_seurat <- readRDS(paste0(seurat_results, "integrated_seurat_snn.rds"))

samples <- setdiff(unique(integrated_seurat@meta.data$Sample), c("FC", "MC"))

# Perform cellchat analysis for each group to be compared
for (i in c("Female", "Male")){
  #for (i in samples){  
  
  # integrated_seurat_subset <- subset(x = integrated_seurat,
  #                                    Sample == i)
  
  integrated_seurat_subset <- subset(x = integrated_seurat,
                                     subset = (Sex == i & Condition == "Tumor"))
  
  integrated_seurat_subset <- subset(x = integrated_seurat_subset,
                                     subset = (cell_class %in% c("Mixed", "Unclassified")),
                                     invert = TRUE)
  cat("No: of cells is  ", nrow(integrated_seurat_subset@meta.data), "\n")
  
  # NOTE: For differential analysis, both groups MUST have same sub_types.
  # Chen data female doesnt have nonCAF subtype but males do. So, differential
  # analysis gives "Error in obj2 - obj1 : non-conformable arrays". So, to make
  # things easy, let us remove non-CAF from male samples.
  # if (proj == "scRNASeq_Chen"){
  #   integrated_seurat_subset <- subset(x = integrated_seurat_subset,
  #                                      #subset = sub_type %in% c("Fibroblasts - nonCAF"),
  #                                      invert = TRUE)
  # }
  
  ############Create cellchat object from seurat object##########################
  
  cellchat <- CellChat::createCellChat(object = integrated_seurat_subset, 
                                       group.by = "cell_type",
                                       #group.by = "sub_type",
                                       datatype = "RNA",  #"spatial"
                                       assay = "RNA")
  # After the previous step, "data", "meta" and "options" slots are populated.
  
  # If using an expression matrix instead of seurat object, you need to add cell 
  # information into meta slot of the cellchat object
  # cellchat <- CellChat::addMeta(object = cellchat, meta = integrated_seurat@meta.data)
  
  # Set the default cell identities. Set "labels" as default cell identity
  # cellchat <- CellChat::setIdent(object = cellchat, ident.use = "labels")
  
  # show factor levels of the cell labels
  levels(cellchat@idents) 
  
  # Number of cells in each cell group
  groupSize <- as.numeric(table(cellchat@idents)) # number of cells in each cell group
  
  # Choose the ligand-receptor interaction database
  if(species == "Homo sapiens"){
    CellChatDB <- CellChat::CellChatDB.human
  } else if (species == "Mus musculus"){
    CellChatDB <- CellChat::CellChatDB.mouse
  }
  
  # Use entire CellChatDB database or only a part of it
  # NOTE: "Secreted Signaling", "ECM-Receptor", "Cell-Cell Contact". 
  # Cell-cell contact and ECM-Receptor are ok for spatial analysis but not for 
  # single cell analysis as cells may/may not be adjacent and such interactions 
  # are most likely false positives 
  # CellChatDB.use <- CellChatDB
  CellChatDB.use <- CellChat::subsetDB(CellChatDB, search = "Secreted Signaling")
  cellchat@DB <- CellChatDB.use
  # After the previous step, only "DB" slot gets populated.
  
  ####Preprocessing the expression data for cell-cell communication analysis####
  
  # Subset the expression data of signaling genes for saving computation cost
  cellchat <- CellChat::subsetData(object = cellchat, features = NULL)
  # After the previous step, only "data.signaling" slot gets populated.
  # Notice the difference dim(cellchat@data) vs dim(cellchat@data.signaling)
  
  # Identify over-expressed ligands or receptors
  # NOTE: identifyOverExpressedGenes() uses expression matrix from data.signaling
  # It identifies over-expressed ligands/receptors in one cell group relative to
  # other cell groups and then identifies over-expressed ligand-receptor 
  # interactions if either ligand or receptor is over-expressed.
  cellchat <- CellChat::identifyOverExpressedGenes(object = cellchat)
  # After the previous step, only "var.features" slot gets populated.
  
  # Identify over-expressed interactions
  cellchat <- CellChat::identifyOverExpressedInteractions(object = cellchat)
  # After the previous step, only "LR" slot gets populated.
  
  # project gene expression data onto PPI (If this step is run, set
  # `raw.use = FALSE` in `computeCommunProb()` in order to use the projected data)
  if (project_data == TRUE){
    if(species == "Homo sapiens"){
      cellchat <- CellChat::projectData(object = cellchat, adjMatrix = PPI.human)
    } else if (species == "Mus musculus"){
      cellchat <- CellChat::projectData(object = cellchat, adjMatrix = PPI.mouse)
    }
  }
  # After the previous step, only "data.project" slot gets populated.
  
  ########Part II: Inference of cell-cell communication network######
  
  # NOTE: Set population.size = TRUE if analyzing unsorted single-cell 
  # transcriptomes, with the reason that abundant cell populations tend to send
  # collectively stronger signals than the rare cell populations
  # NOTE: Set raw.use = FALSE to use the projected data when analyzing single-cell
  # data with shallow sequencing depth because the projected data could help to 
  # reduce the dropout effects of signaling genes, in particular for possible 
  # zero expression of subunits of ligands/receptors.
  cellchat <- CellChat::computeCommunProb(object = cellchat,
                                          raw.use = !project_data,
                                          population.size = unsorted_data)
  # After the previous step, only "net" and "options" slot gets populated.
  
  # Filter out the cell-cell communication if there are only few number of cells in certain cell groups
  cellchat <- CellChat::filterCommunication(object = cellchat, min.cells = 10)
  # After the previous step, the "net" slot gets updated.
  
  # Infer the cell-cell communication at a signaling pathway level
  cellchat <- CellChat::computeCommunProbPathway(object = cellchat)
  # After the previous step, only "netP" slot gets populated.
  
  # Calculate the aggregated cell-cell communication network
  cellchat <- CellChat::aggregateNet(cellchat)
  # After the previous step, only "net" slot gets populated with "count", "weight"
  
  # Compute the network centrality scores
  cellchat <- CellChat::netAnalysis_computeCentrality(object = cellchat, slot.name = "netP")
  # After the previous step, only "netP" slot gets populated with "centr"
  
  ####Save the cellchat object for future use and export interactions to xlsx file
  saveRDS(object = cellchat, file = paste0(cellchat_results, "cellchat_q", i, ".rds"))
  
  # # Extract all inferred cell-cell communications at level of ligands/receptors
  # df.net <- CellChat::subsetCommunication(object = cellchat, slot.name = "net")
  # 
  # # Extract all inferred cell-cell communications at level of  signaling pathways
  # df.netP <- CellChat::subsetCommunication(object = cellchat, slot.name = "netP")
  # 
  # # Save as excel
  # openxlsx::addWorksheet(wb, sheetName = paste0("Ligand-Receptor_", i))
  # openxlsx::writeData(wb, sheet = paste0("Ligand-Receptor_", i), x = df.net, rowNames = TRUE)
  # openxlsx::addWorksheet(wb, sheetName = paste0("Pathways_", i))
  # openxlsx::writeData(wb, sheet = paste0("Pathways_", i), x = df.netP, rowNames = TRUE)
}
# openxlsx::saveWorkbook(wb, 
#                        file = paste0(cellchat_results, "cellchat_interactions.xlsx"), 
#                        overwrite = TRUE)

#******************************************************************************#
#           STEP 2: INVESTIGATE CELL-CELL DIFFERENCES BETWEEN GROUPS           #
#******************************************************************************#

# Read the cellchat objects
cellchat_female <- readRDS(paste0(cellchat_results, "cellchat_Female.rds"))
cellchat_male <- readRDS(paste0(cellchat_results, "cellchat_Male.rds"))

# First merge all cellchat objects before analyzing differences
object.list <- list(Female = cellchat_female, Male = cellchat_male)
cellchat_merged <- CellChat::mergeCellChat(object.list = object.list,
                                           add.names = names(object.list))
# After the previous step, 'data.signaling','images','net', 'netP','meta', 
# 'idents', 'var.features', 'DB', and 'LR' slots get updated

# (10) Identify dysfunctional signaling by comparing communication prob [NOT RECOMMENDED]
# # (a) This method for identifying the upregulated and down-regulated signaling 
# # is perfomed by comparing the communication probability between two datasets 
# # for each L-R pair and each pair of cell groups. (NOT BEST WAY)
# # This can be done by specifying max.dataset (or min.dataset) in netVisual_bubble() 
# # NOTE: The increased signaling means these signaling have higher communication 
# # probability (strength) in one dataset compared to the other dataset.
# gg1 <- CellChat::netVisual_bubble(object = cellchat_merged, 
#                                   sources.use = 4,       #refers to 4th celltype in levels(cellchat_female@idents) 
#                                   targets.use = c(5:11), #refers to 5th to 11th celltypes in levels(cellchat_female@idents) 
#                                   comparison = c(1, 2),  #refers to groups being compared in object.list
#                                   max.dataset = 2,       #sets 2nd group as max
#                                   title.name = "Increased signaling in Female", angle.x = 45, remove.isolate = T)
# gg2 <- CellChat::netVisual_bubble(object = cellchat_merged, 
#                                   sources.use = 4, 
#                                   targets.use = c(5:11),  
#                                   comparison = c(1, 2), 
#                                   max.dataset = 1, 
#                                   title.name = "Decreased signaling in Female", angle.x = 45, remove.isolate = T)
# ggsave(filename = "LR differences (NOT BEST WAY).pdf",
#        plot = gg1 + gg2,
#        device = "pdf",
#        path = cellchat_results)

# (b) Identify dysfunctional signaling using differential expression analysis [ RECOMMENDED]
# Alternative to above method, we can identify the upgulated and down-regulated 
# signaling ligand-receptor pairs based on differential gene expression analysis.
# Specifically, we perform differential expression analysis between two 
# $biological conditions (i.e., NL and LS) for each cell group, and then obtain
# the upgulated and down-regulated signaling based on the fold change of 
# ligands in the sender cells and receptors in the receiver cells. Such analysis
# can be done as follows.

# Set the cell identities before calculating overexpressed genes. 
# NOTE: If cell identity differs from initial step when you calculated 
# communication prob, then you cannot use them. You need to recalculate them if 
# you want to plot them
# cellchat_merged <- CellChat::setIdent(object = cellchat_merged, ident.use = "cell_type")
# levels(cellchat_merged@idents) 

# Perform differential expression analysis [MUST DO]
# This identifies overexpressed ligand, receptors for each cell type within each
# dataset & then calculates logFC for these DEGs in pos.dataset relative to control
cellchat_merged <- CellChat::identifyOverExpressedGenes(object = cellchat_merged, 
                                                        group.dataset = "datasets",  #column in metadata
                                                        pos.dataset = pos.dataset, 
                                                        features.name = features.name, 
                                                        only.pos = FALSE, 
                                                        thresh.pc = 0.2, thresh.fc = 0.2, thresh.p = 0.05)

####Save the cellchat object for future use and export interactions to xlsx file
saveRDS(object = cellchat_merged, file = paste0(cellchat_results, "cellchat_merged.rds"))

# Map the results of differential expression analysis onto the inferred 
# cell-cell communications to easily manage/subset the ligand-receptor pairs of 
# interest. This dataframe is similar to df.net dataframe except that this has more 
# columns like logFC etc. NOTE: positive ligand.logFC means high in pos.dataset
net <- CellChat::netMappingDEG(object = cellchat_merged, features.name = features.name)

# Identify LR pairs based on expression, % of cells expressed, pvalues
net.up <- net %>% 
  dplyr::filter(datasets == "Male" & ligand.logFC >= 0.2 & ligand.pvalues < 0.05 & receptor.logFC >= 0.2 & receptor.pvalues < 0.05) %>%
  dplyr::mutate(expr = log(x=(2^ligand.logFC+2^receptor.logFC)/2, base=2))

net.down <- net %>% 
  dplyr::filter(datasets == "Female" & ligand.logFC <= -0.2 & ligand.pvalues < 0.05 & receptor.logFC <= -0.2 & receptor.pvalues < 0.05) %>%
  dplyr::mutate(expr = log(x=(2^ligand.logFC+2^receptor.logFC)/2, base=2))

# Save as excel
wb <- openxlsx::createWorkbook()
openxlsx::addWorksheet(wb, sheetName = paste0("Ligand-Receptor_DEG_all"))
openxlsx::writeData(wb, sheet = paste0("Ligand-Receptor_DEG_all"), x = net, rowNames = TRUE)
openxlsx::addWorksheet(wb, sheetName = paste0("Ligand-Receptor_DEG_male"))
openxlsx::writeData(wb, sheet = paste0("Ligand-Receptor_DEG_male"), x = net.up, rowNames = TRUE)
openxlsx::addWorksheet(wb, sheetName = paste0("Ligand-Receptor_DEG_female"))
openxlsx::writeData(wb, sheet = paste0("Ligand-Receptor_DEG_female"), x = net.down, rowNames = TRUE)
openxlsx::saveWorkbook(wb, 
                       file = paste0(cellchat_results, "cellchat_interactions_with_fc1.xlsx"), 
                       overwrite = TRUE)

# # We then visualize the upregulated and down-regulated signaling ligand-receptor 
# # pairs using bubble plot or chord diagram.
# # MAJOR ISSUE: The heatmap shows a dot for H2-K1:Cd8a in Epi-Epi (female) despite
# # Cd8a having receptor.logFC as NA. This can be avoided if you dont project 
# # data to PPI. 
# # ANOTHER ISSUE: MIF-CD74 is up in EPi-T cells in male but Fib-T cells in female.
# # The dot plot should IDEALLY ONLY plot comm. prob. in Epithelial upregulated 
# # dotplot but it also plots in Epithelial downregulated dotplot. So, use custom 
# # code to plot.
# # Since the signaling genes in the net.up and net.down might be complex with 
# # multi-subunits, we can do further deconvolution to obtain the individual signaling genes.
# gene.up <- CellChat::extractGeneSubsetFromPair(pairLR = net.up, object = cellchat_merged)
# gene.down <- CellChat::extractGeneSubsetFromPair(pairLR = net.down, object = cellchat_merged)
# pathway.up <- unique(net.up$pathway_name)
# pathway.down <- unique(net.down$pathway_name)
# graphics::par(mfrow = c(1,2), xpd=TRUE)
# grDevices::pdf(file = paste0(cellchat_results, "(10) Dot_plots.pdf"),
#                width = 15, height = 10)
# for (i in setdiff(as.character(sort(unique(net.up$source))), "Myeloid - MDSC")){
#   #gg <- list()
#   pairLR.use.up = net.up[, "interaction_name", drop = F]
#   gg1 <- CellChat::netVisual_bubble(object = cellchat_merged, 
#                                     pairLR.use = pairLR.use.up, 
#                                     sources.use = which(i == levels(cellchat_female@idents), arr.ind=TRUE), 
#                                     targets.use = which(levels(cellchat_female@idents) %in% as.character(sort(unique(net.up$target))), arr.ind=TRUE), 
#                                     comparison = c(1, 2),
#                                     max.dataset = 2,
#                                     angle.x = 90, remove.isolate = T,
#                                     title.name = paste0("Upregulated in ", names(object.list)[2]),
#                                     return.data = FALSE)
#   pairLR.use.down = net.down[, "interaction_name", drop = F]
#   gg2 <- CellChat::netVisual_bubble(object = cellchat_merged, 
#                                     pairLR.use = pairLR.use.down, 
#                                     sources.use = which(i == levels(cellchat_female@idents)), 
#                                     targets.use = which(levels(cellchat_female@idents) %in% as.character(sort(unique(net.up$target)))),
#                                     comparison = c(1, 2), 
#                                     max.dataset = 1,
#                                     angle.x = 90, remove.isolate = T,
#                                     title.name = paste0("Downregulated in ", names(object.list)[2]),
#                                     return.data = FALSE)
#   gg1+gg2
# }
# grDevices::dev.off()

# prepare dataframe for plotting
net.male <- dplyr::bind_rows(net.up, net.down) %>%
  dplyr::mutate(datasets = "Male")

net.female <- net.male %>%
  dplyr::mutate(datasets = "Female", ligand.logFC = 0, receptor.logFC = 0) 

net.diff <- dplyr::bind_rows(net.male, net.female) %>%
  dplyr::filter(grepl(pattern = "Epithelial|Fibroblasts|Myeloid|Lymphoid|Endothelial", x = source) &
                  grepl(pattern = "Epithelial|Fibroblasts|Myeloid|Lymphoid|Endothelial", x = target)) %>%
  dplyr::filter(annotation == "Secreted Signaling") %>%
  dplyr::mutate(expr = log(x=(2^ligand.logFC+2^receptor.logFC)/2, base=2),
                expr_binary =  dplyr::if_else(expr > 0, "HIGH", dplyr::if_else(expr < 0, "LOW", "0"))) %>%
  dplyr::select(interaction_name_2, source, target, datasets, pathway_name, expr, expr_binary)

#Add prob from net df
net.diff <- left_join(x = net.diff,
                      y = net %>% dplyr::select(interaction_name_2, source, target, datasets, prob),
                      by = c("interaction_name_2"="interaction_name_2", "source"="source", "target"="target", "datasets"="datasets"))

plot_dotplot <- function(cell){ 
  
  data1 <- net.diff %>%
    dplyr::filter(grepl(pattern = cell, x = source)) %>%
    dplyr::mutate(col_id = paste0(source, " : ", target, " (", datasets, ")")) %>%
    dplyr::rename(Strength = prob, LR = interaction_name_2) %>%
    dplyr::select(LR, col_id, Strength, pathway_name, expr, expr_binary)
  
  data1$col_id <- stringi::stri_replace_all_regex(str = data1$col_id,
                                                  pattern=c("Male", "Female", "Epithelial", 
                                                            "Endothelial", "Fibroblasts", 
                                                            " - ", "Lymphatic", "Inflammatory",
                                                            "Gamma Delta", "Proliferating", 
                                                            "Lymphoid" ,"Myeloid", "  ", "Myofibrotic", "Mesothelial-like"),
                                                  replacement=c("M", "F", "Epi", "Endo", "Fib",
                                                                " ", "Lym.", "Infl.", "GD", 
                                                                "Prol.", "", "", " ", "Myo.", "Meso."),
                                                  vectorize_all = FALSE)
  
  v_palette <- c(RColorBrewer::brewer.pal(11, "RdYlBu")[c(1)], RColorBrewer::brewer.pal(11, "RdYlBu")[c(11)], "#808080")
  names(v_palette) <- c("HIGH", "LOW", "MID")
  
  rows <- length(unique(data1$LR))
  cols <- length(unique(data1$col_id))
  
  gg1 <- ggplot(data = data1, aes(x=col_id, y = LR, color = expr_binary)) +
    geom_point(size = 5) +
    theme_bw() +
    labs(title = paste0("Differential LR Interactions in ", cell)) +
    scale_color_manual(values = v_palette) +
    theme(axis.text.x =  element_text(family="sans", face="plain", colour="black", size=10, hjust = 0.5, vjust = 0.5, angle = 90))
  
  #patchwork::wrap_plots(plots = gg1, widths = (0.25*cols+3), heights = (0.5*rows+3))
  ggplot2::ggsave(filename = paste0("LR Differences ", cell, ".pdf"),
                  plot = gg1,
                  device = "pdf",
                  width = (0.25*cols+3),
                  height = (0.5*rows+3),
                  path = cellchat_results)
}

# graphics::par(mfrow = c(1,2), xpd=TRUE)
# grDevices::pdf(file = paste0(cellchat_results, "(10) Dot_plots.pdf"),
#                width = 30, height = 20)
purrr::map(.x = c("Epithelial", "Fibroblasts", "Myeloid", "Lymphoid", "Endothelial"),
           .f = plot_dotplot)
#grDevices::dev.off()

# Plot heatmap
plot_heatmap <- function(cell){
  
  data2 <- net.diff %>%
    dplyr::filter(grepl(pattern = cell, x = source)) %>%
    dplyr::filter(datasets != "Female") %>%
    dplyr::filter(grepl(pattern = "Epithelial", x = target)) %>% # Keep only necessary comparisons
    dplyr::mutate(col_id = paste0(source, " : ", target, " (", datasets, ")")) %>%
    dplyr::rename(LR = interaction_name_2) %>%
    dplyr::select(LR, col_id, pathway_name, expr) %>%
    tidyr::pivot_wider(names_from = "col_id",
                       values_from = "expr") %>%
    tibble::column_to_rownames(var = "LR") %>%
    base::replace(is.na(.),0)
  
  mat <- data2 %>%
    dplyr::select(everything(), -c("pathway_name"))
  mat <- mat[, which(colSums(mat) != 0)]
  
  if (nrow(mat) > 0){
    # Define column annotation
    col_annotation <- data.frame("Cell" = gsub(pattern = "^.*: | .*$", replacement ="", x=colnames(mat)))
    rownames(col_annotation) <- colnames(mat)
    
    # Define row annotation
    row_annotation <- data2 %>% dplyr::select(pathway_name)
    rownames(row_annotation) <- rownames(mat)
    
    # Define colors for heatmap
    my_palette <- c(colorRampPalette(rev(brewer.pal(n = 11, name ="RdYlBu")))(100)[1:49], 
                    "#FFFFFF",
                    colorRampPalette(rev(brewer.pal(n = 11, name ="RdYlBu")))(100)[50:99])
    
    # Define colors for row and column annotation
    groups <- sort(unique(col_annotation[[1]]))
    colors <- c("#BF812D", "#35978F", "#C51B7D", "#7FBC41", "#762A83",
                "#E08214", "#542788", "#D6604D", "#4393C3", "#878787",
                "#1A1A1A", "#FFFFBF", "#9E0142", "#E41A1C", "#377EB8",
                "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628",
                "#F781BF", "#999999", "#66C2A5", "#FC8D62", "#000000")
    colors <- colors[1:length(groups)]
    names(colors) <- groups
    ann_colors = list(colors)
    names(ann_colors) <- colnames(col_annotation)
    
    # Define how samples will be arranged in the heatmap.
    # Set cluster_cols=FALSE, if you want to arrange samples in specific order
    # Set cluster_cols=TRUE, if you want to arrange samples based on clustering
    col_annotation <- col_annotation %>% dplyr::arrange(Cell)
    row_annotation <- row_annotation %>% dplyr::arrange(pathway_name)
    mat <- mat[rownames(row_annotation),rownames(col_annotation)]
    
    # List genes and samples you want to display in the plot
    display_row <- rownames(mat)      #c("SMAD6","EFNB2","CDX2)
    display_col <- stringi::stri_replace_all_regex(str = colnames(mat),
                                                   pattern=c("Male", "Female", "Epithelial", "Endothelial", "Fibroblasts", 
                                                             " - ", "Lymphatic", "Inflammatory", "Gamma Delta", "Proliferating", 
                                                             "Lymphoid" ,"Myeloid", "  ", "Myofibrotic", "Mesothelial-like"),
                                                   replacement=c("M", "F", "Epi", "Endo", "Fib", " ", "Lym.", "Infl.", "GD", 
                                                                 "Prol.", "", "", " ", "Myo.", "Meso."),
                                                   vectorize_all = FALSE)
    
    # List where you want to have gaps in the heatmap
    gaps_row <- NULL
    gaps_col <- col_annotation %>% 
      dplyr::count(get(colnames(.)[1])) %>% 
      dplyr::mutate(n = cumsum(n)) %>%
      dplyr::select(n) %>% 
      unlist(use.names=FALSE)
    
    # Determine breaks for heatmap color scale.
    # breaks correspond to numerical ranges for the color palette's bins .i.e. 0 to length(my_palette)
    if(max(mat) == 0){
      breaks <- c(seq(from=min(mat), to=0, length.out=ceiling(100/2) + 1), seq(from=1/100, to=1, length.out=floor(100/2)))
    } else if (min(mat) == 0){
      breaks <- c(seq(from=-1, to=0, length.out=ceiling(100/2) + 1), seq(from=max(mat)/100, to=max(mat), length.out=floor(100/2)))
    } else if(min(mat) < -5 & max(mat) > 5){
      breaks <- c(seq(-3, 0, length.out=ceiling(100/2) + 1), seq(max(mat)/100, 3, length.out=floor(100/2)))
    } else{
      breaks <- c(seq(from=min(mat), to=0, length.out=ceiling(100/2) + 1), seq(from=max(mat)/100, to=max(mat), length.out=floor(100/2)))
    }
    
    # Plot heatmap
    # Error in check.length("fill") :  'gpar' element 'fill' must not be length 0
    # This error means sample_annotation dataframe doesnt match with columns of mat
    # Try using mat = t(mat) to see if it fixes the error
    pheatmap::pheatmap(mat = as.matrix(mat),
                       color = my_palette,
                       breaks = breaks, 
                       border_color = "grey90", #"white"
                       cellwidth = 10, 
                       cellheight = 10, 
                       scale = "none",   
                       cluster_rows = FALSE,   #cluster the rows
                       cluster_cols = FALSE,   #cluster the columns
                       clustering_distance_rows = "euclidean",
                       clustering_distance_cols = "euclidean",
                       clustering_method = "complete",
                       legend = TRUE, 
                       legend_breaks = NA,
                       legend_labels = NA, 
                       annotation_row = row_annotation,
                       annotation_col = col_annotation,
                       annotation_colors = ann_colors,
                       annotation_legend = TRUE,
                       annotation_names_row = FALSE,
                       annotation_names_col = FALSE,
                       show_rownames = dplyr::if_else(nrow(mat)<200, TRUE, FALSE, missing = NULL), 
                       show_colnames = dplyr::if_else(ncol(mat)<200, TRUE, FALSE, missing = NULL),
                       fontsize = 8, 
                       fontsize_row = 8, 
                       fontsize_col = 8,
                       gaps_row = NULL,
                       gaps_col = gaps_col,
                       angle_col = "45",
                       fontsize_number = 0.8*fontsize, 
                       labels_row = c(display_row, rep(x="", times=nrow(mat) - length(display_row))),
                       labels_col = c(display_col, rep(x="", times=ncol(mat) - length(display_col))),
                       width = 15,
                       height = 10,
                       filename = paste0(cellchat_results, "Heatmap_", cell, ".pdf"))
  }
}

purrr::map(.x = c("Epithelial", "Fibroblasts", "Myeloid", "Lymphoid", "Endothelial"),
           .f = plot_heatmap)

# # DOESNT LOOK GOOD
# # Visualize the upgulated and down-regulated signaling ligand-receptor pairs using Chord diagram
# # Chord diagram
# for (i in 1:length(levels(cellchat_female@idents))){
#   par(mfrow = c(1,2), xpd=TRUE)
#   grDevices::pdf(file = paste0(cellchat_results, "Ligand-Receptor Differences (Chord) ", levels(cellchat_female@idents)[i], ".pdf"))
#   CellChat::netVisual_chord_gene(object = object.list[[2]], 
#                                  sources.use = i, 
#                                  targets.use = c(1:length(levels(cellchat_female@idents))), 
#                                  slot.name = 'net', net = net.up, lab.cex = 0.8, small.gap = 3.5, 
#                                  title.name = paste0("Up-regulated signaling in ", names(object.list)[2]))
#   CellChat::netVisual_chord_gene(object = object.list[[1]], 
#                                  sources.use = i, 
#                                  targets.use = c(1:length(levels(cellchat_female@idents))),
#                                  slot.name = 'net', net = net.down, lab.cex = 0.8, small.gap = 3.5, 
#                                  title.name = paste0("Down-regulated signaling in ", names(object.list)[2]))
#   grDevices::dev.off()
# }



# (1) Compare total number of interactions and interaction strength between 
# different biological conditions (group level)
gg1 <- CellChat::compareInteractions(object = cellchat_merged, show.legend = F, group = c(1,2), measure = "count")
gg2 <- CellChat::compareInteractions(object = cellchat_merged, show.legend = F, group = c(1,2), measure = "weight")
gg1 + gg2
ggsave(filename = "(1) Differential Interactions (Column).pdf",
       plot = gg1+gg2,
       device = "pdf",
       path = cellchat_results)

# (2) Compare number of interactions and interaction strength among different 
# cell types between different biological conditions (subtype level)
# NOTE: Red (increased) & Blue (decreased) in 2nd group (male) relative to 
# 1st group (female)
# (a) Circle view (merged plot, line/edge color relative to 1st group):
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(2a) Differential Interactions (All celltypes, Circle).pdf"))
CellChat::netVisual_diffInteraction(object = cellchat_merged, comparison = c(1, 2), weight.scale = T, measure = "count", label.edge = T)
CellChat::netVisual_diffInteraction(object = cellchat_merged, comparison = c(1, 2), weight.scale = T, measure = "weight", label.edge = T)
grDevices::dev.off()

# (b) Heatmap view (merged plot, grid color relative to 1st group):
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(2b) Differential Interactions (All celltypes, Heatmap).pdf"))
CellChat::netVisual_heatmap(object = cellchat_merged, measure = "count")
CellChat::netVisual_heatmap(object = cellchat_merged, measure = "weight")
grDevices::dev.off()

# (c) Circle view (individual plots, line/edge thickness relative to max interactions, weights):
# NOTE: To better control the node size and edge weights of inferred networks 
# across different data sets, we compute maximum number of cells per cell 
# group and maximum number of interactions (or interaction weights) across 
# all datasets.
weight.max <- CellChat::getMaxWeight(object.list = object.list, attribute = c("idents","count"))
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(2c) Interactions (All celltypes, Circle).pdf"))
for (i in 1:length(object.list)) {
  CellChat::netVisual_circle(net = object.list[[i]]@net$count, 
                             weight.scale = T, label.edge= T, 
                             edge.weight.max = weight.max[2], edge.width.max = 12, 
                             title.name = paste0("Number of interactions - ", names(object.list)[i]))
}
grDevices::dev.off()

# VERY CROWDED PLOT
# (d) Due to the complicated cell-cell communication network, we can examine the
# # signaling sent from each cell group. Here we also control the parameter
# # edge.weight.max so that we can compare edge weights between differet networks.
# mat <- cellchat_merged@net$Female$weight
# pdf(file="(2d).pdf")
# par(mfrow = c(3,4), xpd=TRUE)
# for (i in 1:nrow(mat)) {
#   mat2 <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
#   mat2[i, ] <- mat[i, ]
#   netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i])
# }
# dev.off()

# (3) Compare number of interactions and interaction strength among different 
# cell types between different biological conditions (Major cell type level)
# In previous figures, we have multiple subtypes of myeloid and lymphoid cells.
# Below, we merged the different subtypes and plot only cell types.
# NOTE: We have labelled subtypes in such a way that removing all characters 
# after "-" using gsub gives the celltype
levels(cellchat_female@idents) 
group.cellType <- gsub(pattern = " -.*", replacement = "", x=levels(cellchat_female@idents))
group.cellType <- factor(group.cellType)
object.list <- lapply(object.list, function(x) {CellChat::mergeInteractions(object = x, group.merged = group.cellType)})
cellchat_merged <- CellChat::mergeCellChat(object.list, add.names = names(object.list))

# (a) Circle view (merged plot, line/edge color relative to 1st group):
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(3a) Differential Interactions (Major celltypes, Circle).pdf"))
CellChat::netVisual_diffInteraction(object = cellchat_merged, weight.scale = T, measure = "count.merged", label.edge = T)
CellChat::netVisual_diffInteraction(object = cellchat_merged, weight.scale = T, measure = "weight.merged", label.edge = T)
grDevices::dev.off()

# (b) Circle view (individual plots, line/edge thickness relative to max interactions, weights):
weight.max <-  CellChat::getMaxWeight(object.list = object.list, 
                                      slot.name = c("idents", "net", "net"), 
                                      attribute = c("idents","count", "count.merged"))
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(3b) Interactions (Major celltypes, Circle.pdf"))
for (i in 1:length(object.list)) {
  CellChat::netVisual_circle(net = object.list[[i]]@net$count.merged, 
                             weight.scale = T, label.edge= T, 
                             edge.weight.max = weight.max[3], edge.width.max = 12, 
                             title.name = paste0("Number of interactions - ", names(object.list)[i]))
}
grDevices::dev.off()

# (4) Compare major sources (signal sender) & targets (signal receiver) between 
# different biological conditions
# Dot size is proportional to number of inferred links (outgoing and incoming)
# associated with each cell group. 
# Dot colors indicate different cell groups. 
# Dot shapes indicate different categories of cell groups if "group" is defined.
num.link <- sapply(object.list, function(x) {rowSums(x@net$count) + colSums(x@net$count)-diag(x@net$count)})
weight.MinMax <- c(min(num.link), max(num.link)) # control the dot size in the different datasets
gg <- list()
for (i in 1:length(object.list)) {
  gg[[i]] <- CellChat::netAnalysis_signalingRole_scatter(object = object.list[[i]], 
                                                         title = names(object.list)[i], 
                                                         weight.MinMax = weight.MinMax)
}
grDevices::pdf(file = paste0(cellchat_results, "(4) Sources, Targets (All celltypes).pdf"),
               width = 11, height = 8.5)
patchwork::wrap_plots(plots = gg)
grDevices::dev.off()

# (5) Identify signaling changes associated with each cell group
# NOTE: Positive values indicate the increase in the second dataset while 
# negative values indicate the increase in the first dataset
# NOTE: levels(cellchat@idents) is same as  levels(cellchat@idents$Male) 
# cellchat_merged@idents is actually a list of Male, Female and joint
gg <- list()
for (i in 1:length(levels(cellchat_female@idents))) {
  gg[[i]] <- CellChat::netAnalysis_signalingChanges_scatter(object = cellchat_merged, 
                                                            idents.use = levels(cellchat_female@idents)[i]) +
    theme(legend.position = "none")
}
grDevices::pdf(file = paste0(cellchat_results, "(5) Signaling changes (All celltypes).pdf"),
               width = 20,
               height = 20)
patchwork::wrap_plots(plots = gg)
grDevices::dev.off()

#*****************USEFUL IF COMPARING NORMAL VS CANCER DATASETS****************#

# Use (6) to identify conserved as well as context specific signaling pathways.
# (6) will generate a scatter plot of signaling pathways in 2 datasets being 
# compared. It will also cluster these pathways based on functional/structural 
# similarity. So, if any cluster has more pathways for a specific dataset, then
# those are context-specific. Pathways common to both datasets are conserved.

# (6) Identify signaling groups based on their functional/structural similarity
# NOTE: High degree of functional similarity indicates major senders and
# receivers are similar, and it can be interpreted as the two signaling pathways
# or two ligand-receptor pairs exhibit similar and/or redundant roles.
# NB: Functional similarity analysis is not applicable to multiple datasets with
# different cell type composition. In such case, change type="structural"
cellchat_merged <- CellChat::computeNetSimilarityPairwise(object = cellchat_merged, type = "functional", comparison=c(1,2))
cellchat_merged <- CellChat::netEmbedding(object = cellchat_merged, type = "functional")
cellchat_merged <- CellChat::netClustering(object = cellchat_merged, type = "functional")
# After the previous step, "netP" slot gets updated with "similarity".
CellChat::netVisual_embeddingPairwise(object = cellchat_merged, type = "functional", label.size = 3.5)
ggsave(filename = "(6a) Signaling groups clustered (Functional).pdf",
       plot = last_plot(),
       device = "pdf",
       path = cellchat_results)

# Use below code to see if any cluster is enriched for a specific group.
# If is is difficult to count from the below plot, count manually from 
# cellchat_merged@netP$similarity$functional$group
# netVisual_embeddingZoomIn(cellchat_merged, type = "functional", nCol = 4)
# Alternatively, (7) automatically calculates pathways that are different between
# 2 datasets (larger distance) vs those that are similar (smaller distance). 
# However, (7) cannot clearly indicate if they are conserved or context specific.
# (8) can clearly show pathways that are conserved (have red & green bars) vs
# those that are context-specific (have only red or only green bars)

# (7) Compute and visualize the pathway distance in the learned joint manifold
# NOTE: Larger distance implies larger difference of the communication network
# between two datasets in terms of either functional or structure similarity. 
# NB: We only compute the distance of overlapped signaling pathways between two 
# datasets. Signaling pathways that are only identified in one dataset are not 
# considered here. If there are more than three datasets, one can do pairwise
# comparisons by defining comparison in the function rankSimilarity.
CellChat::rankSimilarity(object = cellchat_merged, type = "functional")
ggsave(filename = "(7) Signaling groups ranked (Functional).pdf",
       plot = last_plot(),
       device = "pdf",
       path = cellchat_results)

# (8) Compare the overall information flow of each signaling pathway
# We can identify the conserved and context-specific signaling pathways by 
# simply comparing the information flow for each signaling pathway, which is 
# defined by the sum of communication probability among all pairs of cell 
# groups in the inferred network (i.e., the total weights in the network).
# By comparing the information flow/interaction strengh of each signaling 
# pathway, we can identify signaling pathways, (i) turn off, (ii) decrease, 
# (iii) turn on or (iv) increase, by change their information flow at one 
# condition as compared to another condition.
# Significant signaling pathways were ranked based on differences in the overall
# information flow within the inferred networks between 2 groups. 
# Top enriched signaling pathways colored red or green.
gg1 <- CellChat::rankNet(cellchat_merged, mode = "comparison", stacked = T, do.stat = TRUE)
gg2 <- CellChat::rankNet(cellchat_merged, mode = "comparison", stacked = F, do.stat = TRUE)
ggsave(filename = "(8) Signaling groups differences (Functional).pdf",
       plot = gg1 + gg2,
       device = "pdf",
       height = 20,
       path = cellchat_results)

#******************************************************************************#

# Go through the plot from (8) and choose some pathways you want to investigate 
# further. Here we have chosen pathways that were enriched in male or female 
# in both human and mice datasets
levels(cellchat_female@idents) 
group.cellType <- gsub(pattern = " -.*", replacement = "", x=levels(cellchat_female@idents))
pathways.show <- list(pathways = c("MK", "PROS", "EGF", "ANGPT", "OSM", "MIF", "COMPLEMENT", "TWEAK", "ANNEXIN", "CCL"), 
                      sources = c())
# "LIFR"),

# (9) Identify which cells acts as source, target, mediator etc for these pathways
# (a) Determine which cells act as main source of signaling for these pathways
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(9) Sender_Receiver.pdf"),
               width = 15, height = 12)

for (j in 1:length(pathways.show$pathways)){
  ht <- list()
  for (i in 1:length(object.list)) {
    ht[[i]] <- CellChat::netVisual_heatmap(object = object.list[[i]], 
                                           signaling = pathways.show$pathways[j], 
                                           measure = c("weight"),
                                           color.heatmap = "Reds",
                                           title.name = paste(pathways.show$pathways[j], "signaling ",names(object.list)[i]))
  }
  ComplexHeatmap::draw(ht[[1]] + ht[[2]], ht_gap = unit(0.5, "cm"))
}
grDevices::dev.off()

# (b) Identify senders, receivers, mediators and influencers for these pathways
# Alternatively, use (9b) to easily visualize rather than (9a)
# Visualize the computed centrality scores using heatmap, allowing ready 
# identification of major signaling roles of cell groups
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(9) Sender_Receiver_Mediator_Influencer.pdf"),
               width = 15)

for (j in 1:length(pathways.show$pathways)){
  gg <- list()
  for (i in 1:length(object.list)) {
    gg[[i]] <- CellChat::netAnalysis_signalingRole_network(object = object.list[[i]],
                                                           signaling = pathways.show$pathways[j],
                                                           width = 15,
                                                           height = 5,
                                                           font.size = 10)
  }
  patchwork::wrap_plots(plots = gg)
}
grDevices::dev.off()

# Go through the plots and list the main sources for each pathway so we can
# investigate further
pathways.show <- list(pathways = c("MK", "PROS", "EGF", "ANGPT", "OSM", 
                                   "MIF", "COMPLEMENT", "TWEAK", "ANNEXIN", "CCL"),
                      sources = c("Fibroblasts", "Fibroblasts", "Epithelial", "Endothelial", "Myeloid", 
                                  "Epithelial", "Fibroblasts", "Fibroblasts", "Epithelial", "Myeloid"))


# (c) Plot heirarchy plot in male and female for each of these pathways
# NOTE: User "MUST" define vertex.receiver, which is a numeric vector giving the
# index of the cell groups as targets in the left part of hierarchy plot. 
# This hierarchical plot consist of two components: the left portion shows
# autocrine and paracrine signaling to certain cell groups of interest 
# (i.e, the defined vertex.receiver), and the right portion shows autocrine and
# paracrine signaling to the remaining cell groups in the dataset. Thus, 
# hierarchy plot provides an informative and intuitive way to visualize 
# autocrine and paracrine signaling communications between cell groups of 
# interest. For example, when studying the cell-cell communication between 
# fibroblasts and immune cells, USER can define vertex.receiver as all 
# fibroblast cell groups.

graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(9) Hierarchy_plots.pdf"),
               width = 15, height = 10)

for (j in 1:length(pathways.show$pathways)){
  
  # Define main senders for each pathway
  sources <- which(group.cellType == pathways.show$sources[j])
  
  # control the edge weights across different datasets
  weight.max <- getMaxWeight(object.list, slot.name = c("netP"), attribute = pathways.show$pathways[j]) 
  
  for (i in 1:length(object.list)) {
    CellChat::netVisual_aggregate(object = object.list[[i]], 
                                  signaling = pathways.show$pathways[j], 
                                  vertex.receiver = sources,
                                  layout = "hierarchy", 
                                  edge.weight.max = weight.max[1], 
                                  edge.width.max = 10,
                                  vertex.label.cex = 0.5,
                                  signaling.name = paste0(pathways.show$pathways[j], "(", names(object.list)[i], ")"))
  }
}
grDevices::dev.off()

# (d) Compute the contribution of each ligand-receptor pair to overall signaling
# pathway and visualize cell-cell communication mediated by a single 
# ligand-receptor pair
graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(9) LR_contribution.pdf"),
               width = 15)

for (j in 1:length(pathways.show$pathways)){
  gg <- list()
  
  for (i in 1:length(object.list)){
    gg[[i]] <- CellChat::netAnalysis_contribution(object = object.list[[i]],
                                                  signaling = pathways.show$pathways[j],
                                                  title = paste("Contribution of each L-R pair in ", 
                                                                pathways.show$pathways[j], "signaling (", names(object.list)[i], ")"))
  }
  patchwork::wrap_plots(plots = gg)
}
grDevices::dev.off()

# (9) Compare outgoing/incoming signaling associated with each cell population
# The above analysis summarize the information from the outgoing and incoming 
# signaling together. We can also compare the outgoing (or incoming) signaling
# pattern between two datasets, allowing to identify signaling 
# pathways/ligand-receptors that exhibit different signaling patterns.
# We can combine all the identified signaling pathways from different datasets
# and thus compare them side by side, including outgoing signaling, incoming 
# signaling and overall signaling by aggregating outgoing and incoming signaling
# together. NB: rankNet also shows the comparison of overall signaling, but it 
# does not show the signaling strength in specific cell populations.
library(ComplexHeatmap)
i = 1
# combining all the identified signaling pathways from different datasets 
pathway.union <- union(object.list[[i]]@netP$pathways, object.list[[i+1]]@netP$pathways)

graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(9a) Signal-Outgoing (All celltypes, Heatmap).pdf"),
               height = 12)
CellChat::netAnalysis_signalingRole_heatmap(object = object.list[[i]], 
                                            pattern = "outgoing", 
                                            signaling = pathway.union, 
                                            title = names(object.list)[i], 
                                            width = 5, height = 20, color.heatmap = "GnBu")
CellChat::netAnalysis_signalingRole_heatmap(object = object.list[[i+1]], 
                                            pattern = "outgoing", 
                                            signaling = pathway.union, 
                                            title = names(object.list)[i+1], 
                                            width = 5, height = 20, color.heatmap = "GnBu")
grDevices::dev.off()

graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(9b) Signal-Incoming (All celltypes, Heatmap).pdf"),
               height = 12)
CellChat::netAnalysis_signalingRole_heatmap(object = object.list[[i]], 
                                            pattern = "incoming", 
                                            signaling = pathway.union, 
                                            title = names(object.list)[i], 
                                            width = 5, height = 20, color.heatmap = "GnBu")
CellChat::netAnalysis_signalingRole_heatmap(object = object.list[[i+1]], 
                                            pattern = "incoming", 
                                            signaling = pathway.union, 
                                            title = names(object.list)[i+1],
                                            width = 5, height = 20, color.heatmap = "GnBu")
grDevices::dev.off()

graphics::par(mfrow = c(1,2), xpd=TRUE)
grDevices::pdf(file = paste0(cellchat_results, "(9c) Signal-All (All celltypes, Heatmap).pdf"),
               height = 12)
CellChat::netAnalysis_signalingRole_heatmap(object = object.list[[i]], 
                                            pattern = "all", 
                                            signaling = pathway.union, 
                                            title = names(object.list)[i], 
                                            width = 5, height = 20, color.heatmap = "OrRd")
CellChat::netAnalysis_signalingRole_heatmap(object = object.list[[i+1]], 
                                            pattern = "all", 
                                            signaling = pathway.union, 
                                            title = names(object.list)[i+1], 
                                            width = 5, height = 20, color.heatmap = "OrRd")
grDevices::dev.off()

# (11) Visualize the enriched ligands, signaling,or ligand-receptor pairs in one
# condition compared to another condition using wordcloud
grDevices::pdf(file = paste0(cellchat_results, "Enriched Ligands, Signaling and LR-pair in ", names(object.list)[1], ".pdf"))
CellChat::computeEnrichmentScore(df = net.down, measure = "ligand", species = dplyr::if_else(species == "Mus musculus", "mouse", "human"))
CellChat::computeEnrichmentScore(df = net.down, measure = "signaling", species = dplyr::if_else(species == "Mus musculus", "mouse", "human"))
CellChat::computeEnrichmentScore(df = net.down, measure = "LR-pair", species = dplyr::if_else(species == "Mus musculus", "mouse", "human"))
grDevices::dev.off()

grDevices::pdf(file = paste0(cellchat_results, "Enriched Ligands, Signaling and LR-pair in ", names(object.list)[2], ".pdf"))
CellChat::computeEnrichmentScore(df = net.up, measure = "ligand", species = dplyr::if_else(species == "Mus musculus", "mouse", "human"))
CellChat::computeEnrichmentScore(df = net.up, measure = "signaling", species = dplyr::if_else(species == "Mus musculus", "mouse", "human"))
CellChat::computeEnrichmentScore(df = net.up, measure = "LR-pair", species = dplyr::if_else(species == "Mus musculus", "mouse", "human"))
grDevices::dev.off()


#####Part IV: Visualization of cell-cell communication network######

# # We can also visualize the cell-cell communication mediated by a single 
# # ligand-receptor pair. We provide a function extractEnrichedLR to extract all 
# # the significant interactions (L-R pairs) and related signaling genes for a 
# # given signaling pathway.
# pairLR.CXCL <- extractEnrichedLR(cellchat, signaling = pathways.show, geneLR.return = FALSE)
# LR.show <- pairLR.CXCL[1,] # show one ligand-receptor pair
# # Hierarchy plot
# vertex.receiver = seq(1,4) # a numeric vector
# netVisual_individual(cellchat, signaling = pathways.show,  pairLR.use = LR.show, vertex.receiver = vertex.receiver)
# pdf(file="6.pdf")
# # Circle plot
# netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show, layout = "circle")
# # Chord diagram
# netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show, layout = "chord")
# dev.off()
