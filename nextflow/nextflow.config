// =========================================================================================
// NEXTFLOW CONFIGURATION FILE
// =========================================================================================
// Purpose: Central configuration for RNA-seq pipeline
//
// This file defines:
//   1. Execution reports (trace, timeline, report)
//   2. Container runtime (Singularity settings)
//   3. Parameters (paths, tool arguments)
//   4. Execution profiles (SGE, local, AWS)
//   5. Process resources and output directories
//
// Usage:
//   nextflow run main.nf -params-file project_info.yaml -profile sge -resume
//
// Configuration hierarchy (later overrides earlier):
//   nextflow.config defaults → project_info.yaml → command-line flags
// =========================================================================================

// =========================================================================================
// GLOBAL PARAMETERS
// =========================================================================================
// Initialize default values (overridden by project_info.yaml)

// Initialize empty maps for YAML-provided parameters
params.star_align       = params.star_align           ?: [:]
params.salmon_quant     = params.salmon_quant         ?: [:]
params.cellranger_count = params.cellranger_count     ?: [:]
params.stop_after       = params.stop_after           ?: ""

params {

    // =====================================================================================
    // DYNAMIC PATH CLOSURES
    // =====================================================================================
    // CRITICAL: Use closures { } to delay evaluation until runtime
    // This allows paths to incorporate values from project_info.yaml
    //
    // Without closures:
    //   params.project = "test"
    //   params.proj_dir = "${params.base_dir}/${params.project}"
    //   [YAML loads: project = "Xinyi"]
    //   params.proj_dir still = ".../test" (evaluated too early!)
    //
    // With closures:
    //   params.proj_dir = { "${params.base_dir}/${params.project}" }
    //   [YAML loads: project = "Xinyi"]
    //   params.proj_dir() now correctly returns ".../Xinyi"

    // 1. Initialize defaults for YAML variables (prevents config parsing errors)
    read_dir       = null
    base_dir       = null
    expt           = null
    project        = null
    map_file       = null
    assay          = null
    cache_dir      = null

    reference = [:]
    reference.ref_dir         = null
    reference.fasta_file      = null
    reference.gtf_file        = null
    reference.species         = null
    reference.genome_version  = null

    // 2. User defined
    // Dynamic path closures (MUST use { } syntax, MUST call with () )
    raw_fastq_dir   = { params.read_dir }
    species         = { params.reference.species }
    genome_version  = { params.reference.genome_version }
    fasta           = { params.reference.fasta_file }
    gtf             = { params.reference.gtf_file }
    map             = { params.map_file }

    // 3. Project output files and directories
    // Note: Since ref_gtf is a closure, use () to execute the closure before string replacement
    ref_dir                = { "${params.reference.ref_dir}/${params.reference.species}" }
    star_index_dir         = { "${params.ref_dir()}/star_index_dir" }
    salmon_index_dir       = { "${params.ref_dir()}/salmon_index_dir" }
    cellranger_index_dir   = { "${params.ref_dir()}/cellranger_index_dir" }
    ref_fasta              = { "${params.ref_dir()}/${params.fasta()}" }
    ref_gtf                = { "${params.ref_dir()}/${params.gtf()}" }
    ref_bed                = { params.ref_gtf().replaceAll(/\.gtf$/, '.bed') }
    housekeeping_bed       = { params.ref_gtf().replaceAll(/\.gtf$/, '.housekeeping.bed') }

    proj_dir        = { "${params.base_dir}/${params.expt}/${params.project}" }
    fastq_dir       = { "${params.proj_dir()}/01.FastQ" }
    srr_fastq_dir   = { "${params.proj_dir()}/01.FastQ/srr" }
    fastqc_dir      = { "${params.proj_dir()}/02.FastQC" }
    cellranger_dir  = { "${params.proj_dir()}/03.CellRanger" }
    salmon_dir      = { "${params.proj_dir()}/03.Salmon" }
    star_dir        = { "${params.proj_dir()}/04.STAR" }
    rseqc_dir       = { "${params.proj_dir()}/05.RSEQC" }
    multiqc_dir     = { "${params.proj_dir()}/06.MultiQC" }
    log_dir         = { "${params.proj_dir()}/07.Logs" }

    // =====================================================================================
    // TOOL ARGUMENTS
    // =====================================================================================
    // Construct argument lists from YAML parameters
    // These are called in main.nf and pre-joined to prevent cache invalidation

    // SALMON arguments
    SALMON_ARGS = {
        def args = ["--libType",                 params.salmon_quant.libType                         ?: "A"]
        if (params.salmon_quant?.gcBias)  { args.add("--gcBias")  }
        if (params.salmon_quant?.seqBias) { args.add("--seqBias") }
        if (params.salmon_quant?.posBias) { args.add("--posBias") }
        return args
    }

    // STAR arguments
    STAR_ARGS = {
        def samtype = params.star_align?.outSAMtype ?: ["BAM", "SortedByCoordinate"]

        return [
            "--runMode",                         params.star_align?.runMode                         ?: "alignReads",
            "--twopassMode",                     params.star_align?.twopassMode                     ?: "Basic",
            "--quantMode",                       params.star_align?.quantMode                       ?: "GeneCounts",
            "--sjdbOverhang",                    (params.star_align?.sjdbOverhang                   ?: 100).toString(),
            "--readFilesCommand",                params.star_align?.readFilesCommand                ?: "zcat",
            "--outFilterMultimapNmax",           (params.star_align?.outFilterMultimapNmax          ?: "10").toString(),
            "--outFilterMismatchNmax",           (params.star_align?.outFilterMismatchNmax          ?: "999").toString(),
            "--outFilterMismatchNoverReadLmax",  (params.star_align?.outFilterMismatchNoverReadLmax ?: "0.04").toString(),
            "--outFilterType",                   params.star_align?.outFilterType                   ?: "BySJout",
            "--alignEndsType",                   params.star_align?.alignEndsType                   ?: "Local",
            "--alignIntronMin",                  (params.star_align?.alignIntronMin                 ?: "20").toString(),
            "--alignIntronMax",                  (params.star_align?.alignIntronMax                 ?: "1000000").toString(),
            "--alignMatesGapMax",                (params.star_align?.alignMatesGapMax               ?: "1000000").toString(),
            "--outSAMattributes",                params.star_align?.outSAMattributes                ?: "NH HI AS nM MD",
            "--outSAMunmapped",                  params.star_align?.outSAMunmapped                  ?: "Within",
            "--outSAMtype",                      samtype[0], samtype[1]
        ]
    }

    // CELLRANGER COUNT arguments
    CELLRANGER_ARGS = {
        def args = ["--chemistry",                      params.cellranger_count?.chemistry                      ?: "auto",
                    "--include-introns",                params.cellranger_count?.include_introns                ?: "true",
                    "--check-library-compatibility",    params.cellranger_count?.check_library_compatibility    ?: "true",
                    "--create-bam",                     params.cellranger_count?.create_bam                     ?: "false"]

        // 1. Handle Token and Annotation Logic
        def tokenFile = params.cellranger_count?.tenx_cloud_token_path

        // Only if tokenFile is NOT null/empty, we append the cloud flags
        if (tokenFile && tokenFile != "null") {
            args.add("--cell-annotation-model")
            args.add(params.cellranger_count?.cell_annotation_model ?: "auto")
            args.add("--tenx-cloud-token-path")
            args.add("${params.cellranger_index_dir()}/${tokenFile}")
        }
        return args
    }
}

// =========================================================================================
// EXECUTION PROFILES
// =========================================================================================
// Profiles configure the execution environment
// Combine multiple: nextflow run main.nf -profile sge -params-file project_info.yaml

profiles {

    // =====================================================================================
    // ENVIRONMENT PROFILES
    // =====================================================================================

    // LOCAL: Run on local machine (for testing with small datasets)
    standard {
        process.executor = 'local'
        process.cpus     = 4
        process.memory   = 16.GB
    }

    // SGE: Sun Grid Engine cluster execution
    // Each process submitted as separate SGE job
    sge {
        process.executor       = 'sge'
        process.queue          = 'all.q'          // SGE queue name (use: qconf -sql)
        process.penv           = 'smp'            // Parallel environment (use: qconf -spl)
        process.clusterOptions = { "-S /bin/bash" }

        executor {
            queueSize = "50"  // Max simultaneous jobs submitted to SGE
        }
    }

    // AWS: AWS Batch execution (requires Docker, not Singularity)
    aws {
        process.executor = 'awsbatch'
        process.queue    = 'your-job-queue-name'
        process.memory   = { task.memory.toMega() }

        aws {
            region = 'us-east-1'
            batch {
                jobRole              = 'arn:aws:iam::YOUR_ACCOUNT_ID:role/AmazonBatchServiceRole'
                cliPath              = '/home/ec2-user/miniconda/bin/aws'
                maxParallelTransfers = 5  // Avoid RequestLimitExceeded errors
            }
        }

        docker.enabled      = true
        singularity.enabled = false
    }
}

// =========================================================================================
// PROCESS EXECUTION SETTINGS
// =========================================================================================
// Defines resources, error handling, and output directories

process {

    // =====================================================================================
    // DEFAULT SETTINGS (Applied to all processes)
    // =====================================================================================

    //cache = 'lenient'  // Resume even if some inputs changed slightly

    // Error handling: Only retry if out-of-memory, otherwise fail fast
    errorStrategy = { task.exitStatus in [137, 139, 140, 143] ? 'retry' : 'terminate' }
    maxRetries    = 3

    // Default resources (for unlabeled processes)
    cpus   = 1
    memory = 2.GB

    // =====================================================================================
    // RESOURCE TIERS
    // =====================================================================================
    // Processes labeled by computational requirements
    // Memory scales with task.attempt for automatic retry with more resources

    withLabel: 'process_low' {
        cpus   = 2
        memory = { 3.GB * task.attempt }   // 3GB → 6GB → 9GB on retries
    }

    withLabel: 'process_medium' {
        cpus   = 4
        memory = { 12.GB * task.attempt }  // 12GB → 24GB → 36GB on retries
    }

    withLabel: 'process_high' {
        cpus   = 8
        memory = { 48.GB * task.attempt }  // 48GB → 96GB → 144GB on retries
    }

    // =====================================================================================
    // PROCESS-SPECIFIC CONFIGURATIONS
    // =====================================================================================
    // Each process has custom publishDir to organize outputs

    // -------------------------------------------------------------------------------------
    // FastQC: Quality control on FASTQ files
    // -------------------------------------------------------------------------------------
    withName: 'RENAME_FASTQS' {
        publishDir = [
            [path: { "${params.fastq_dir()}/raw" },     mode: 'copy',     pattern: "*.{fastq,fq}.gz"],
            [path: { params.log_dir() },                mode: 'copy',     pattern: "*.RENAME_FASTQS.error.log"]
        ]
    }

    // -------------------------------------------------------------------------------------
    // FastQC: Quality control on FASTQ files
    // -------------------------------------------------------------------------------------
    withName: 'FASTQC' {
        container = 'quay.io/biocontainers/fastqc:0.12.1--hdfd78af_0'
        publishDir = [
            [path: { "${params.fastqc_dir()}/${read_type}" },     mode: 'copy',     pattern: "*.html"],
            [path: { "${params.fastqc_dir()}/${read_type}" },     mode: 'copy',     pattern: "*.zip"],
            [path: { params.log_dir() },                          mode: 'copy',      pattern: "*.FASTQC.error.log"]
        ]
    }

    // -------------------------------------------------------------------------------------
    // Reference indexing: Store in reference directory (reusable across projects)
    // -------------------------------------------------------------------------------------
    withName: 'STAR_INDEX' {
        container = 'quay.io/biocontainers/star:2.7.11b--h5ca1c30_4'
        storeDir  = { params.ref_dir() }
    }

    withName: 'EXTRACT_GENTROME' {
        container = 'quay.io/biocontainers/gffread:0.12.7--h077b44d_6'
        storeDir  = { params.ref_dir() }
    }

    withName: 'SALMON_INDEX' {
        container = 'quay.io/biocontainers/salmon:1.10.3--h45fbf2d_5'
        storeDir  = { params.ref_dir() }
    }

    withName: 'RSEQC_BED' {
        container = 'quay.io/biocontainers/mulled-v2-6ab052c2a495e1ceaab8525e0897839fed1d9f74:dd7404a5c5f1a50099356d334fde1c5657327e50-0'
        storeDir  = { params.ref_dir() }
    }

    // -------------------------------------------------------------------------------------
    // Salmon quantification: Multiple publishDir for different file types
    // -------------------------------------------------------------------------------------
    withName: 'SALMON_QUANT' {
        container = 'quay.io/biocontainers/salmon:1.10.3--h45fbf2d_5'
        publishDir = [
            [path: { params.salmon_dir() },                     mode: 'copy',    saveAs: { filename -> filename.endsWith('.sf') || filename.endsWith('.log') ? null : filename }],
            [path: { "${params.salmon_dir()}/quant_files" },    mode: 'copy',    pattern: "*.quant.sf"],
            [path: { params.log_dir() },                        mode: 'copy',    pattern: "*.SALMON_QUANT.error.log"]
        ]
    }

    // -------------------------------------------------------------------------------------
    // STAR alignment: Multiple outputs organized by type
    // -------------------------------------------------------------------------------------
    withName: 'STAR_ALIGN' {
        container = 'quay.io/biocontainers/star:2.7.11b--h5ca1c30_4'
        publishDir = [
            [path: { "${params.star_dir()}/gene_counts" },        mode: 'copy',    pattern: "*.ReadsPerGene.out.tab"],
            [path: { "${params.star_dir()}/splice_junction" },    mode: 'copy',    pattern: "*.SJ.out.tab"],
            [path: { "${params.star_dir()}/alignment_stats" },    mode: 'copy',    pattern: "*.Log.final.out"],
            [path: { params.log_dir() },                          mode: 'copy',    pattern: "*.STAR_ALIGN.error.log"]
        ]
    }

    // -------------------------------------------------------------------------------------
    // Sambamba: BAM indexing and subsampling
    // -------------------------------------------------------------------------------------
    withName: 'SAMBAMBA_PREP' {
        container = 'quay.io/biocontainers/sambamba:1.0.1--he614052_4'
        publishDir = [
            [path: { "${params.star_dir()}/bam" },    mode: 'copy',    pattern: "*.{bam,bam.bai}",      saveAs: { filename -> filename.contains('.1M') ? null : filename }],
            [path: { params.log_dir() },              mode: 'copy',    pattern: "*.SAMBAMBA_PREP.error.log"]
        ]
    }

    // -------------------------------------------------------------------------------------
    // RSeQC: Alignment QC (organized by analysis type)
    // -------------------------------------------------------------------------------------
    withName: 'RSEQC' {
        container = 'quay.io/biocontainers/rseqc:5.0.4--pyhdfd78af_1'
        publishDir = [
            [path: { "${params.rseqc_dir()}/01_read_distribution" },    mode: 'copy',    pattern: "*.read_distribution*"],
            [path: { "${params.rseqc_dir()}/02_inner_distance" },       mode: 'copy',    pattern: "*.inner_distance*"],
            [path: { "${params.rseqc_dir()}/03_junction_annotation" },  mode: 'copy',    pattern: "*.{splice*pdf,junction_summary.txt,junction_plot.r,junction.bed,junction.xls}"],
            [path: { "${params.rseqc_dir()}/04_junction_saturation" },  mode: 'copy',    pattern: "*junctionSaturation*"],
            [path: { "${params.rseqc_dir()}/05_deletion_profile" },     mode: 'copy',    pattern: "*.deletion_profile*"],
            [path: { "${params.rseqc_dir()}/06_mismatch_profile" },     mode: 'copy',    pattern: "*.mismatch_profile*"],
            [path: { "${params.rseqc_dir()}/07_insertion_profile" },    mode: 'copy',    pattern: "*.insertion_profile*"],
            [path: { "${params.rseqc_dir()}/08_clipping_profile" },     mode: 'copy',    pattern: "*.clipping_profile*"],
            [path: { "${params.rseqc_dir()}/09_gene_body_coverage" },   mode: 'copy',    pattern: "*.geneBodyCoverage*"],
            [path: { params.log_dir() },                                mode: 'copy',    pattern: "*.RSEQC.error.log"]
        ]
    }

    // -------------------------------------------------------------------------------------
    // CellRanger: Alignment QC
    // -------------------------------------------------------------------------------------
    withName: 'CELLRANGER_COUNT' {
        container = { "${params.cache_dir}/cellranger-10.0.0.sif" }
        publishDir = [
            [path: { params.log_dir() },               mode: 'copy',    pattern: "*.CELLRANGER_COUNT.error.log"],
            [path: { params.cellranger_dir() },        mode: 'copy',    saveAs: { filename ->
                def whitelist = ["filtered_feature_bc_matrix", "raw_feature_bc_matrix", "analysis", "cell_types",
                                 "bam", "bai", "csv", "html", "h5", "json", "cloupe"]

                if (whitelist.any { filename.contains(it) }) {
                    return filename.replace('outs/', '')            // This removes 'outs/' and saves as "SampleA/web_summary.html"
                }
                return null
            }]
        ]
    }

    //[sample_id]/
    // └── outs/
    //       ├── possorted_genome_bam.bam         <-- BAM file
    //       ├── possorted_genome_bam.bam.bai     <-- BAM index
    //       ├── filtered_feature_bc_matrix/      <-- Folder
    //       ├── raw_feature_bc_matrix/           <-- Folder
    //       ├── analysis/                        <-- Folder
    //       ├── cell_types/                      <-- Folder
    //       ├── metrics_summary.csv
    //       └── web_summary.html

    // -------------------------------------------------------------------------------------
    // MultiQC: Aggregate QC reports
    // -------------------------------------------------------------------------------------
    withName: 'MULTIQC' {
        container = 'quay.io/biocontainers/multiqc:1.33--pyhdfd78af_0'
        publishDir = [
            [path: { params.multiqc_dir() },    mode: 'copy',    pattern: "*.html"],
            [path: { params.multiqc_dir() },    mode: 'copy',    pattern: "*_data"],
            [path: { params.log_dir() },        mode: 'copy',    pattern: "*.MULTIQC.error.log"]
        ]
    }
}

// =========================================================================================
// CONTAINER RUNTIME CONFIGURATION
// =========================================================================================
// Singularity settings for HPC environments
// Dynamic bind mounts passed from run_nextflow.sh script

params.dynamic_binds = ""  // Populated by run_nextflow.sh

singularity {
    enabled     = true
    autoMounts  = false                    // Disable automatic mount detection (causes issues)
    cacheDir    = "${params.cache_dir}"    // Store downloaded images here (shared across projects)
    runOptions  = params.dynamic_binds     // Bind mounts calculated dynamically by run_nextflow.sh
}

// =========================================================================================
// EXECUTION REPORTS
// =========================================================================================
// Nextflow generates execution reports for monitoring and debugging
// All reports saved to ${params.log_dir}/

trace {
    enabled   = true
    overwrite = true
    file      = "${params.log_dir()}/trace.txt"
    // Contains: task_id, process, status, exit_code, duration, memory, cpus, disk_read, disk_write
}

report {
    enabled   = true
    overwrite = true
    file      = "${params.log_dir()}/report.html"
    // Contains: resource usage, task completion times, success/failure statistics
}

timeline {
    enabled   = true
    overwrite = true
    file      = "${params.log_dir()}/timeline.html"
    // Contains: Gantt chart showing task execution timeline
}

dag {
    enabled   = true
    overwrite = true
    file      = "${params.log_dir()}/flowchart.html"
    // Contains: Visual representation of the workflow logic and process dependencies
}

// =========================================================================================
// CONFIGURATION NOTES
// =========================================================================================
//
// ADDING NEW PROJECTS:
//   - No need to add profiles anymore - use project_info.yaml instead
//   - Just configure project_info.yaml with your paths and settings
//   - Run: nextflow run main.nf -params-file project_info.yaml -profile sge -resume
//
// RESOURCE TUNING:
//   - Adjust memory multipliers in withLabel blocks if jobs fail
//   - Check timeline.html to see actual resource usage
//   - Increase maxRetries if transient failures occur
//
// PUBLISHDIR MODES:
//   - 'copy': Copies files (safe, uses disk space)
//   - 'symlink': Creates links (saves space, fragile if work/ deleted)
//   - 'move': Moves files (fastest, removes from work/)
//   Current: Using 'copy' for reliability
//
// TROUBLESHOOTING:
//   - Check .nextflow.log for configuration errors
//   - Review trace.txt for resource usage
//   - Inspect timeline.html for bottlenecks
//   - Look in work/xx/yyyy.../.command.log for task-specific errors
//
// CLEANUP:
//   - After successful run: rm -rf ${work_dir}/*
//   - This frees disk space but prevents -resume
//   - Keep work/ during development/testing
//
// =========================================================================================
